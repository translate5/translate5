<?php

namespace MittagQI\Translate5\Plugins\TermImport\Services\Across;

use SoapFault;

class SoapConnector extends \SoapClient
{
    protected static $ACROSS_API_URL_WSDL = '/crossAPI/crossAPI.wsdl';

    protected static $ACROSS_API_URL_ACTION = 'http://tempuri.org/crossAPI/action/';

    /**
     * Container to hold the securityToken generated by Across.
     *
     * @var string|null
     */
    protected ?string $securityToken = null;

    /**
     * Container to hold the current soap-action. Will be set in __soapCall() (if needed) and used in __doRequest()
     *
     * @var string|null
     */
    protected ?string $currentAction = null;

    /**
     * Initialize the soap connection and load the across securityToken which is need for every soap-request
     * @throws Exception
     */
    public function __construct($apiUrl, $apiLogin, $apiPass, array $additionalOptions = [])
    {
        $soapConfig = [
            'location' => $apiUrl . self::$ACROSS_API_URL_WSDL,
            'soap_version' => SOAP_1_1,
            'trace' => 1,
            'login' => $apiLogin,
            'password' => $apiPass,
        ];
        $soapConfig = array_merge($soapConfig, $additionalOptions);

        try {
            parent::__construct($apiUrl . self::$ACROSS_API_URL_WSDL, $soapConfig);
            $this->createSecurityToken($apiLogin, $apiPass);
        } catch (SoapFault $e) {
            //E1456 Error on connecting to Across under "{url}"
            throw new Exception('E1456', [
                'url' => $soapConfig['location'],
            ], $e);
        }
    }

    /**
     * Create the Across securityToken and store it in $this->securityToken.
     * This securityToken is needed for authorisation in each and every crossApi-call.
     * on error throws \MittagQI\Translate5\Plugins\TermImport\Services\Across\Exception
     */
    protected function createSecurityToken($apiLogin, $apiPassword)
    {
        $result = $this->__soapCall('Authorization.CreateSecurityToken', [$apiLogin, $apiPassword]);

        if ($result->errorcode) {
            //E1457: can not create Across security token
            throw new Exception('E1457', [
                'result' => $result,
            ]);
        }

        $this->securityToken = $result->data;
    }

    /**
     * This function does 2 things:<br>
     * <ol><li>Handle Across-Objects:<br>
     * In across all functions are capsulated in Objects, e.g. TaskManager.GetJobStatus. Here the Acroos-object is "TaskManager" and the actual function called is "GetJobStatus".
     * The PHP soap-client does not handle this object-capsulated-funtion correct. So here all
     * </li><li>"Recall":<br>
     * All soap calls that lead to a SoapFault-Exception or to an across-answer-error must/should be repeated up to 10 times.
     * </li></ol>
     *
     * {@inheritDoc}
     * @throws Exception
     * @see SoapClient::__soapCall()
     * @return mixed
     */
    public function __soapCall($function_name, $arguments, $options = null, $input_headers = null, &$output_headers = null, $iteration = 0) : mixed
    {
        // reset an previously set action.
        if ($iteration == 0) {
            $this->currentAction = null;
        }

        // Check if a function with object is sumbitted, e.g. 'TaskManager.GetJobStatus'.
        // If so, the action for the request must be stored and the function must be reseted to the pure function-name (without the object)
        if (strpos($function_name, '.')) {
            $this->currentAction = self::$ACROSS_API_URL_ACTION . $function_name;

            $tempFunction = explode('.', $function_name);
            $function_name = $tempFunction[1];
        }

        // try call for 10 times before stopping on a SoapFault exception
        try {
            return parent::__soapCall($function_name, $arguments, $options, $input_headers, $output_headers);
        } catch (SoapFault $e) {
            if ($iteration >= 10) {
                //E1458: Error on communication with Across
                throw new Exception('E1458', [
                    'function' => $function_name,
                    //'arguments' => $arguments, contains credentials
                    'options' => $options,
                    'input_headers' => $input_headers,
                    'output_headers' => $output_headers,
                ], $e);
            }
            usleep(300000); // wait for a while until the next call is submitted (!unit is microseconds, so 1.000.000 is one second)

            return $this->__soapCall($function_name, $arguments, $options, $input_headers, $output_headers, ++$iteration);
        }
    }

    /**
     * Handles Across-Objects. For more information see doc of $this->__soapCall()
     * {@inheritDoc}
     * @see SoapClient::__doRequest()
     * @return string
     */
    public function __doRequest($request, $location, $action, $version, $one_way = 0) : string
    {
        if (! is_null($this->currentAction)) {
            $action = $this->currentAction;
        }

        return parent::__doRequest($request, $location, $action, $version, $one_way);
    }

    /**
     * Create a temporary file on the Across server
     * @throws Exception
     */
    protected function createFileStream($filename)
    {
        // create a temporary file
        $params = [$this->securityToken, $filename];
        $result = $this->__soapCall('FileManager.CreateFileStream', $params);

        if ($result->errorcode) {
            // E1459: can not create temporary filestream
            throw new Exception('E1459', [
                'result' => $result,
            ]);
        }

        return $result->data;
    }

    /**
     * Get the content of the file $fileGuid created from Across.
     *
     * @param string $fileGuid
     * @return string (binary)
     */
    protected function getFileFromServer($fileGuid)
    {
        $params = [$this->securityToken, $fileGuid];
        $result = $this->__soapCall('FileManager.GetFileFromServer', $params);

        if ($result->errorcode) {
            // E1460: Can not read from file with fileguid {fileGuid}
            throw new Exception('E1460', [
                'result' => $result,
                'fileGuid' => $fileGuid,
            ]);
        }

        return $result->data;
    }

    /**
     * Remove a temporary file on teh Across server
     * @param string $fileGuid
     */
    protected function removeFileFromServer($fileGuid)
    {
        // remove the temporary file
        $params = [$this->securityToken, $fileGuid];
        $result = $this->__soapCall('FileManager.RemoveFileFromServer', $params);
    }

    /**
     * Wait until the job of the across-API-object $acrossApiObjectName with guid $guid is finished.
     * on error throws \MittagQI\Translate5\Plugins\TermImport\Services\Across\Exception
     *
     * @param string $acrossApiObjectName <br>
     * e.g. 'TaskManager', 'DocumentManager', ... an element of the list under https://wiki.across.net/display/ASCS/crossAPI+SI+Objects+Description
     * @param string $guid
     *
     * @return bool
     * @throws Exception
     */
    protected function waitUntilJobIsFinished(string $acrossApiObjectName, string $guid)
    {
        $params = [$this->securityToken, $guid];
        $result = $this->__soapCall($acrossApiObjectName . '.GetJobStatus', $params);

        if ($result->errorcode) {
            // E1455: can not wait until job "{job}" is finished
            throw new Exception('E1455', [
                'job' => $acrossApiObjectName,
                'result' => $result,
            ]);
        }

        // if job is still running
        if ($result->data === 0) {
            usleep(500000); // wait for 0.5 seconds

            return $this->waitUntilJobIsFinished($acrossApiObjectName, $guid);
        }
        sleep(1);

        return true;
    }
}