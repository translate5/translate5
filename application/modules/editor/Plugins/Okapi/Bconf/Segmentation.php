<?php
/*
 START LICENSE AND COPYRIGHT

 This file is part of translate5

 Copyright (c) 2013 - 2022 Marc Mittag; MittagQI - Quality Informatics;  All rights reserved.

 Contact:  http://www.MittagQI.com/  /  service (ATT) MittagQI.com

 This file may be used under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE version 3
 as published by the Free Software Foundation and appearing in the file agpl3-license.txt
 included in the packaging of this file.  Please review the following information
 to ensure the GNU AFFERO GENERAL PUBLIC LICENSE version 3 requirements will be met:
 http://www.gnu.org/licenses/agpl.html

 There is a plugin exception available for use with this release of translate5 for
 translate5: Please see http://www.translate5.net/plugin-exception.txt or
 plugin-exception.txt in the root folder of translate5.

 @copyright  Marc Mittag, MittagQI - Quality Informatics
 @author     MittagQI - Quality Informatics
 @license    GNU AFFERO GENERAL PUBLIC LICENSE version 3 with plugin-execption
 		     http://www.gnu.org/licenses/agpl.html http://www.translate5.net/plugin-exception.txt

 END LICENSE AND COPYRIGHT
 */

/**
 * Class processing SRX files on import and repacking outdated bconfs
 * Also the upload/processing of SRX files is covered here
 */
final class editor_Plugins_Okapi_Bconf_Segmentation {

    const NAME_MAXLENGTH = 25;

    /**
     * @var editor_Plugins_Okapi_Bconf_Segmentation|null
     */
    private static ?editor_Plugins_Okapi_Bconf_Segmentation $_instance = NULL;

    /**
     * Classic Singleton
     * @return editor_Plugins_Okapi_Bconf_Segmentation
     */
    public static function instance() : editor_Plugins_Okapi_Bconf_Segmentation {
        if(self::$_instance == NULL){
            self::$_instance = new editor_Plugins_Okapi_Bconf_Segmentation();
        }
        return self::$_instance;
    }

    /**
     * Creates the name to be used in case a srx was upladed and both SRX's have the same name - what is the normal case
     * The sent name may is a download-filename generated by T% which looks like $bconfName.'-translate-'.$variant;
     * @param string $sentName
     * @param string $field
     * @param string $otherField
     * @return string
     */
    public static function createCustomFile(string $sentName, string $field, string $otherField) : string {
        $newName = pathinfo($sentName, PATHINFO_FILENAME);
        if(str_contains($sentName, 'languages')){
            $parts = explode($sentName, 'languages');
            $newName = 'languages-'.trim($parts[1], '-_');
            if(strlen($newName) > self::NAME_MAXLENGTH){
                $newName = trim(substr($newName, 0, self::NAME_MAXLENGTH), '-_');
            }
        } else {
            $newName = trim(substr('languages-'.trim($sentName,'-'), 0, self::NAME_MAXLENGTH), '-_');
        }
        if($newName === 'languages-'.$otherField || $newName === 'languages'){
            $newName = 'languages-'.$field;
        }
        return $newName.'.'.editor_Plugins_Okapi_Bconf_Segmentation_Srx::EXTENSION;
    }
    /**
     * @var bool
     */
    private bool $doDebug;
    /**
     * @var editor_Plugins_Okapi_Bconf_Segmentation_Translate5
     */
    private editor_Plugins_Okapi_Bconf_Segmentation_Translate5 $t5segmentation;

    private function __construct(){
        $this->doDebug = ZfExtended_Debug::hasLevel('plugin', 'OkapiBconfValidation');
        $this->t5segmentation = editor_Plugins_Okapi_Bconf_Segmentation_Translate5::instance();
    }

    /**
     * Updates the SRX files to the current version in an unpacking action
     * Triggered by unpacking a bconf
     * @param editor_Plugins_Okapi_Bconf_Pipeline $pipeline
     * @param string $folderPath
     * @throws ZfExtended_Exception
     * @throws editor_Models_ConfigException
     * @throws editor_Plugins_Okapi_Exception
     */
    public function onUnpack(editor_Plugins_Okapi_Bconf_Pipeline $pipeline, string $folderPath){
        $this->updateSrx($folderPath.'/'.$pipeline->getSrxFile('source'), 'unpack');
        // we only need to process the target if it is not identical to the source (what is the default structure9
        if(!$pipeline->hasIdenticalSourceAndTargetSrx()){
            $this->updateSrx($folderPath.'/'.$pipeline->getSrxFile('target'), 'unpack');
        }
    }

    /**
     * Updates a SRX to the current version in an re-packing action
     * Triggered by re-packing an outdated bconf
     * @param string $path
     */
    public function onRepack(string $path){
        $this->updateSrx($path, 'repack');
    }

    /**
     * Evaluates, if the passed SRX is a default SRX. If so, the SRXs content is updated to the new version
     * @param editor_Plugins_Okapi_Bconf_Segmentation_Srx $srx
     */
    public function isDefaultSrx(editor_Plugins_Okapi_Bconf_Segmentation_Srx $srx){
        $data = $this->findCurrentReplacementData($srx->getHash());
        if($data->path == NULL || !$data->match){
            return false;
        }
        if($data->update){
            $srx->setContent(file_get_contents($data->path));
        }
        return true;
    }

    /**
     * @param string $path
     * @param string $action
     * @throws ZfExtended_Exception
     * @throws editor_Models_ConfigException
     * @throws editor_Plugins_Okapi_Exception
     */
    private function updateSrx(string $path, string $action){
        $content = file_get_contents($path);
        if($content === false){
            throw new ZfExtended_Exception('Can not read SRX file from path '.$path);
        }
        $hash = editor_Plugins_Okapi_Bconf_ResourceFile::createHash($content);
        $data = $this->findCurrentReplacementData($hash);
        if($data->path != NULL && $data->match && $data->update){
            // simple overwrite in the file-system
            unlink($path);
            copy($data->path, $path);
            // DEBUG
            if($this->doDebug){ error_log('SRX SEGMENTATION: '.$action.': updated '.$path.' to the current version '.basename($data->path)); }
        } else {
            // DEBUG
            if($this->doDebug){ error_log('SRX SEGMENTATION: '.$action.': no need to update '.$path.', its either custom or current'); }
        }
    }

    /**
     * Finds the current SRX to replace the one with the passed hash
     * Returns no path either if the passed hash is actual or if it was not found
     * @param string $hash
     * @return stdClass
     * @throws editor_Models_ConfigException
     * @throws editor_Plugins_Okapi_Exception
     */
    private function findCurrentReplacementData(string $hash) : stdClass {
        $data = new stdClass();
        $data->match = false;
        $data->update = false;
        $data->path = NULL;
        $matchingItem = $this->t5segmentation->findByHash($hash);
        if($matchingItem != NULL){
            $data->match = true;
            $currentItem =  $this->t5segmentation->findCurrent();
            if($currentItem->version > $matchingItem->version){
                $data->update = true;
                $data->field = ($matchingItem->sourceHash === $hash) ? 'source' : 'target';
                $data->path = $this->t5segmentation->createSrxPath($currentItem, $data->field);
            }
        }
        return $data;
    }
}
